

Programmed Macros in vile
==========================

	[ The following documentation is copied almost verbatim from
	chapter 13 of "MicroEMACS Full Screen Text Editor Reference Manual,
	Version 3.10 March 19, 1989" The copyright for that document is
	"(C)opyright 1988, 1989 by Brian Straight and Daniel M. Lawrence".
	I have done a global substitute of "vile" for "MicroEMACS", and
	adjusted the document in various other small ways to make it match
	vile's current functionality.  (Paul Fox, 4/94) ]

	[ The documentation has since been updated to reflect macro language
	changes added by vile's developers. (10/98) ]

	[ More examples of vile macros can be found in the file vile.hlp . ]

	Macros are programs that are used to customize the editor and to
	perform complicated editing tasks.  They may be stored in files or
	buffers and may be executed using an appropriate command, or bound
	to a particular keystroke.

	There are many different aspects to this macro language.  Editor
	commands are the various commands that manipulate text, buffers,
	windows, et cetera, within the editor.  Directives are commands
	which control what lines get executed within a macro.  Also there
	are various types of variables.  Environmental variables both
	control and report on different aspects of the editor.  User
	variables hold string values which may be changed and inspected.
	Buffer variables allow text to be placed into variables.
	Interactive variable allow the program to prompt the user for
	information.  Functions can be used to manipulate all these
	variables.

	Each of these language aspects will be described in turn, but first
	the execution framework must be explained.


Creating, executing, storing macros
-----------------------------------
	In the simplest case, valid macro language constructs are placed in
	a file or buffer and subsequently executed with one of these editor
	commands:

		command          applies to    example
		-------          ----------    -------
		execute-buffer   buffer        execute-buffer cfgcmds
		execute-file     disk file     execute-file ~/.projcfg
		source           disk file     source c:/utils/proj.cfg

	The most common example of this usage is vile's startup file,
	which is "sourced" during the editor's invocation.  Typically, the
	startup file configures the user's preferences and looks something
	like this:

	        set ai
	        set ts=4
	        set flash
	        <etc.>

	A startup/configuration file might also use macro language
	directives to conditionally configure the editor.  For example, if
	xvile executes this startup file fragment:

	        ~if &sequal $progname "xvile"
	            set-variable $title $cbufname
	        ~endif

	then the editor's X window titlebar changes.  However, "standard"
	vile (i.e., non-gui vile) ignores this fragment and thus, a single
	startup file can be used to configure both the gui and non-gui
	versions of the editor.

	vile also provides constructs that encapsulate macro language
	elements as numbered and named programs.  These programs represent
	the entity that most programmers identify as a "true" macro.
	And in fact, the remainder of this document will simply assume that
	the word "macro" refers to one of aforementioned program types.

    Numbered macros
    ---------------
	The numbered macro syntax looks like so:

	        <number> store-macro
	            <language element>
	                ...
	            <language element>
	        ~endm

	A numbered macro is executed using this command:

	        execute-macro-<number>

	To bind a keystroke to this macro, use this command:

	        bind-key execute-macro-<number> <keystroke>

	Here's an actual example:

	        30 store-macro
	            write-message "this is a test macro"
	        ~endm
	        bind-key execute-macro-30 #h

	Now, whenever "#h" is pressed, a message is written on the editor's
	message line.

	Although this syntax serves a purpose, it's obvious that numbered
	programs don't lend themselves to easy recall (quick, what does
	macro 22 do?).  But this format was an integral part of vile for
	many years, simply because named macros could not be bound to
	keystrokes.  Thankfully, this restriction has recently been removed
	and so, in general, numbered macros are obsolete.  However, vile's
	help file and other related documents still heavily use this format.
	Consequently, familiarity with this outdated syntax is a must.

    Named macros
    ------------
	A named macro, aka "stored procedure", uses this syntax:

	        store-procedure <unique-name> ["help-string"]
	            <language element>
	                ...
	            <language element>
	        ~endm

	where:

	unique-name    is an alpha-numeric identifier that does not conflict
	               with the name of any existing editor command (the
	               show-commands command generates a list of all existing
	               commands).

	               Note:  due to vile's use of the underscore ('_') as a
	               command terminator, this character should _not_ be
	               used as a word separator within "unique-name".
	               Instead, use either a hypen ('-') or mixed case
	               alphabetics.

	help-string    is an optional description of the macro.  This string
	               is displayed in the listing created by show-commands.

	A stored procedure is executed by simply referencing its name.  To
	bind a keystroke to this macro, use this command:

	        bind-key <unique-name> <keystroke>

	Here's the stored procedure equivalent of macro number 30 above:

	        store-procedure write-msg-tst "displays test message"
	            write-message "this is a test macro"
	        ~endm
	        bind-key write-msg-tst #h

	Two mechanisms now exist for executing this macro:

	+ press "#h" within the editor, or

	+ simply use the name "write-msg-tst" as if it were any other
	  built-in editor command.  This means that "write-msg-tst" can be
	  invoked from another macro, from a startup/configuration file, or
	  from vile's command line, like so:

	        :write-msg-tst

    Storing macros
    --------------
	In general, macros are stored in the editor's startup file.
	Prolific macro authors may instead opt to sprinkle their macros
	across one or more external text files and source those file(s)
	from the startup file.


===========================================================================
This concludes the discussion of the macro language execution framework.

The remainder of this document describes individual language constructs.
The presentation is bottom-up (i.e., reference format), so individual
sections may be read in any order.
===========================================================================


Misc macro syntax features
--------------------------
	Any line beginning with a semi-colon (;) or double-quote (")
	character is ignored.  The semi-colon is inherited from MicroEMACS,
	the double-quote is for vi compatibility.

	Lines ending with '\' are joined before interpretation.


Limits
------
	Generally speaking, the length of a constant or variable may not
	exceed 127 bytes of storage.  Then again, there are cases where
	this limit is bumped up to 255 bytes, particularly when a command
	requires a filename as an argument.  But to be on the safe side
	when coding a macro, assume that any string exceeding 127 bytes
	will be truncated.


Constants
---------
	All constants and variable contents are stored as strings of
	characters.  Numbers are stored digit by digit as characters.  This
	allows the variables to be "typeless", not having different
	variables types be legal in different contexts.  This has the
	disadvantage of forcing the user to be more careful about the
	context of the statements variables are placed in, but in turn
	gives them more flexibility in where they can place variables.
	Needless to say, this also allows the expression evaluator to be
	both concise and quick.

	Wherever statements need to have arguments, it is legal to place
	constants.  A constant is a double quote character, followed by a
	string of characters, and terminated by another double quote
	character.  To represent various special characters within a
	constant, the backslash (\) character is used.  The character
	following the backslash is interpreted according to the following
	table:

	Sequence        Result
	\n              ^J      newline character
	\r              ^M      carriage return
	\\              \       backslash
	\b              ^H      backspace
	\f              ^L      formfeed
	\t              ^I      tab
	\a              ^G      bell
	\s                      space
	\"              "       quote
	\xNN		0xNN	the character in hex
	\NNN		NNN	the character in octal

	Any character not in the table which follows a backslash will be
	passed unmodified.  This action is similar to the ^V
	quote-character command available from the keyboard.

	The double quotes around constants are not needed if the constant
	contains no internal white space and it also does not happen to
	meet the rules for any other commands, directives, variables, or
	functions.  This is reasonably useful for numeric constants.


Variables
---------
	Variables can be used to return values within expressions, as
	repeat counts to editing commands, or as text to be inserted into
	buffers and messages.  The value of these variables is set using
	the set-variable command.  The shorter form, "setv", may also
	always be used.  For example, to set the current column position to
	64, the following macro line would be used:

		set-variable $curcol 64

	or to have the contents of %name inserted at the point in the
	current buffer, the command to use would be:

		insert-string %name



Environmental Variables
-----------------------
	These variables are used to change different aspects of the way the
	editor works.  Also they will return the current settings if used
	as part of an expression.  All environmental variable names begin
	with a dollar sign ($) and are in lower case.

	$abufname	[READ ONLY] Name of the "other" buffer, the one most
			recently visited.  This is what you would get if you
			typed '#' at a prompt.

	$bchars		[READ ONLY] Number of characters in current buffer.

	$blines		[READ ONLY] Number of lines in current buffer.

	$buffer-hook	Name of procedure to run when switching to a buffer.

	$cbufname	Name of the current buffer.

	$cd-hook	Name of procedure to run when changing directories.

	$cfgopts	[READ ONLY] Comma-delimited list of "interesting"
			compiled options.  Currently tracked options include:

			perl        -> editor includes perl interpreter
			oleauto     -> editor supports OLE automation.

			If none of the above options are available, $cfgopts
			will be empty ("").

	$cfilname	File name of the current buffer.

	$char		Ascii value of the character currently at the point.

	$cryptkey	[WRITE ONLY] encryption key.

	$curcol 	Current column of point in current buffer.

	$curline	Current line of point in current buffer.

	$cwd		Current working directory.

	$cwline 	Current display line in current window.

	$debug		Flag to trigger macro debugging.

	$directory	Controls location of temp files.  unused.

	$discmd 	Flag to disable the echoing of messages on the
			command line.

	$disinp 	Flag to disable the echoing of characters
			during command line input.

	$end-of-cmd	true if user ended the cmd with <CR>

	$exit-hook	Name of procedure to run when quitting.

	$flicker	Flicker Flag set to TRUE if IBM CGA set to
			FALSE for most others.

	$font		Name of the current font (X11/winvile only).

	$forward-search	search direction, true=forward

	$helpfile	help-filename (vile.hlp)

	$iconname	under X11, contains current icon name.

	$identifier	the name of the current "identifier-like" word under
			the cursor.

	$kill		This contains the first 127 characters currently
			in the kill buffer and can be used to set the
			contents of the kill buffer.

	$lastkey	[READ ONLY] Last keyboard character typed.

	$line		The current line in the current buffer can be
			retrieved and set with this environment variable.

	$llength	[READ ONLY] Returns the number of characters in
			the current line.

	$majormode	[READ ONLY] Current majormode, if any.

	$match		[READ ONLY] Last string matched in a search.

	$mode		[READ ONLY] "insert", "command", or "overwrite" mode.

	$modeline-format format of mode lines.  See "Mode line customization"
	                 in the vile help file.

	$modified	[READ ONLY] is current buffer modified or not?

	$ncolors	Number of displayed colors, must be power of two.

	$ntildes	Percent of window filled by ~ chars, at end of buffer.

	$ocwd		[READ ONLY] Previous directory.

	$os		[READ ONLY] Operating system for which was vile was
			built.  Currently "unix", "dos", "vms", "os/2", "win32".

	$pagelen	Number of screen lines used currently.

	$pagewid	Number of screen columns used currently.

	$palette	string used to control the color mappings in some
			versions.  The usual form consists of digits setting
			the red, green, and blue levels.

	$patchlevel	[READ ONLY] current patch-level (empty for release).

	$pathname	[READ ONLY] current "path-like" word, under the cursor.

	$pending	[READ ONLY] Flag to determine if there are user
			keystrokes waiting to be processed.

	$pid		[READ ONLY] returns vile's process-id.

	$progname	[READ ONLY] Contains the string "vile" "xvile", or,
			"winvile" as appropriate.

	$qidentifier	the name of the current "qualified-identifier-like"
			word under the cursor, useful for C++ programmers.

	$read-hook	Name of procedure to run after a file is read.

	$replace	Current default replace string.

	$search 	Current default search string.

	$seed		Integer seed of the random number generator.

	$shell		Name of the shell program for spawned commands.

	$sres		Current screen resolution on a PC (meaningless on a
			Win32 host).  Values:
			  "2",	   "25",    "80x25",
			  "4",	   "43",    "80x43",
			  "5",	   "50",    "80x50",
			  "80x14", "80x28",
			  "40x12", "40x21", "40x25", "40x28", "40x50"

	$startup-file	the name of the startup file (e.g. .vilerc)

	$startup-path	where to find the startup file

	$status 	[READ ONLY] Status of the success of the last
			command (TRUE or FALSE).  This is usually used with
			~force to check on the success of a search, or a
			file operation.

	$title		The current window title (X11, win32 versions only).

	$tpause 	On a PC, time to pause for paren matching.

	$version	[READ ONLY] Contains the current vile version number.

	$wline		Number of display lines in current window.

	$word		[READ ONLY] The current "word" under the cursor.

	$write-hook	Name of procedure to run before a file is written

	$xdisplay	The value to set $DISPLAY when running $xshell.

	$xshell		Name of the terminal program for spawned xvile commands.


Mode variables
--------------
	You may set and use the values of the editor modes (i.e., universal
	modes, buffer-only modes or window-only modes) as if they were
	environment variables (e.g., "setv $errorbells=true").  The global
	values of the editor modes are not visible to the expression
	evaluator.

	Realistically, this feature is little used, since vile's set/setl
	commands, as well as the &global/&local functions, serve the same
	purpose.


User variables
--------------
	User variables allow you, the user, to store strings and manipulate
	them.  These strings can be pieces of text, numbers (in text form),
	or the logical values TRUE and FALSE.  These variables can be
	combined, tested, inserted into buffers, and otherwise used to
	control the way your macros execute.  All users variable names must
	begin with a percent sign (%) and may contain any printing
	characters.


Buffer variables
----------------
	Buffer variables (a '<' followed by a buffer name) return the
	current line of the specified buffer, automatically setting the
	position to the next line.


Interactive variables
---------------------
	Interactive variables are actually a method to prompt the user for
	a string.  This is done by using an at sign (@) followed either
	with a quoted string, or a variable containing a string.  The
	string is then placed on the bottom line, and the editor waits for
	the user to type in a string.  Then the string typed in by the
	user is returned as the value of the interactive variable.  For
	example:

		set-variable %quest "What file? "
		find-file @%quest

	will ask the user for a file name, and then attempt to find it.
	Note also that complex expressions can be built up with these
	operators, such as:

	@&cat &cat "File to decode[" %default "]: "

		which prompts the user with the concatenated string.


Functions
---------
	Functions can be used to manipulate variables in various ways.
	Functions can have one, two, or three arguments.  These arguments
	will always be placed after the function on the current command
	line.  For example, if we wanted to increase the current fill
	column by two, using the set-variable command, we would write:

		setv $fillcol &add $fillcol 2
		 \      \      \      \     \____second operand
		  \      \      \      \_________first operand
		   \      \      \_______________function to execute
		    \      \_____________________variable to set
		     \___________________________set-variable command

	Function names always begin with the ampersand (&) character, and
	are only significant to the first three characters after the
	ampersand.  Functions will normally expect one of three types of
	arguments, and will automatically convert types when needed.

	<num>         an ascii string of digits which is interpreted
		      as a numeric value.  Any string which does not
		      start with a digit or a minus sign (-) will be
		      considered zero.


	<str>         An  arbitrary  string  of  characters.  At the
		      moment, strings are limited to  127 characters
		      in length.

	<log>         A  logical  value  consisting  of  the  string
		      "TRUE" or "FALSE".   Numeric strings will also
		      evaluate to "FALSE" if they are equal to zero,
		      and "TRUE" if they  are  non-zero.   Arbitrary
		      text strings will have the value of "FALSE".

	A list of the currently available functions follows: Functions are
	always used in lower case, the uppercase letters in the function
	table are the short form of the function (i.e.  &div for &divide).

	Numeric Functions:      (returns <num>)

	&ADD            <num> <num>     Add two numbers
	&SUB            <num> <num>     Subtract the second number from the
					first
	&TIMes          <num> <num>     Multiply two numbers
	&DIVide         <num> <num>     Divide the first number by the second
					giving an integer result
	&MOD            <num> <num>     Return the reminder of dividing the
					first number by the second
	&NEGate         <neg>           Multiply the arg by -1
	&LENgth         <str>           Returns length of string
	&SINdex         <str1> <str2>   Finds the position of <str2> within
					<str1>. Returns zero if not found.
	&ASCii          <str>           Return the ascii code of the first
					character in <str>
	&RND            <num>           Returns a random integer between 1 and
					<num>
	&ABS            <num>           Returns the absolute value of <num>

	String manipulation functions:  (returns <str>)

	&CAT            <str> <str>     Concatenate the two strings to form
					one
	&LEFt           <str> <num>     return the <num> leftmost characters
					from <str>
	&RIGht          <str> <num>     Starting from <num> position in <str>,
					return substring to the right.
	&MID            <str> <num1> <num2>
					Starting from <num1> position in <str>,
					return <num2> characters.
	&UPPer          <str>           Uppercase <str>
	&LOWer          <str>           lowercase <str>
	&CHR            <num>           return a string with the character
					represented by ascii code <num>
	&GTK                            return a string containing a single
					keystroke from the user
	&GTS                            read single keystroke from user, return
					equivalent keycode sequence (e.g., #1)
	&ENV            <str>           If the operating system is capable,
					this returns the environment string
					associated with <str>
	&TRIm           <str>           Trim leading and trailing whitespace
					from <str> and collapse multiple,
					embedded whitespace chars to a
					single space.
	&BINd           <str>           return the function name bound to the
					keystroke <str>

	Logical Testing functions:      (returns <log>)

	&NOT            <log>           Return the opposite logical value
	&AND            <log1> <log2>   Returns TRUE if BOTH logical arguments
					are TRUE
	&OR             <log1> <log2>   Returns TRUE if either argument
					is TRUE
	&EQUal          <num> <num>     If <num> and <num> are numerically
					equal, return TRUE
	&LESs           <num1> <num2>   If <num1> is less than <num2>, return
					TRUE.
	&GREater        <num1> <num2>   If <num1> is greater than, or equal to
					<num2>, return TRUE.
	&SEQual         <str1> <str2>   If the two strings are the same,
					return TRUE.
	&SLEss          <str1> <str2>   If <str1> is less alphabetically than
					<str2>, return TRUE.
	&SGReater       <str1> <str2>   If <str1> is alphabetically greater
					than or equal to <str2>, return TRUE.
	&RD          	<str>           Is the named file <str> readable?
	&WR          	<str>           Is the named file <str> writable?

	Special Functions:

	&GLObal		<modename>	retrieves universal/global mode setting
	&LOCal		<modename>	retrieves local mode setting

	&INDirect       <str>           Evaluate <str> as a variable.

	This last function deserves more explanation.  The &IND function
	evaluates its argument, takes the resulting string, and then uses
	it as a variable name.  For example, given the following code
	sequence:

		; set up reference table

		setv %one        "elephant"
		setv %two        "giraffe"
		setv %three      "donkey"

		setv %index "two"
		insert-string &ind %index

	the string "giraffe" would have been inserted at the point in the
	current buffer.  This indirection can be safely nested up to about
	10 levels.


Directives
----------
	Directives are commands which only operate within an executing
	macro, i.e.,  they do not make sense as a single command.  As such,
	they cannot be called up singly or bound to keystroke.  Used within
	macros, they control what lines are executed and in what order.

	Directives always start with the tilde (~) character and must be
	the first thing placed on a line.  Directives executed
	interactively (via the execute-command- line command) will be
	ignored.


    ~ENDM Directive
    ---------------
	This directive is used to terminate a macro being stored.  For
	example, if a file is being executed contains the text:

		;       Read in a file in view mode, and make the window red
		;	(color is only settable on some platforms, e.g. DOS)

		26      store-macro
			find-file @"File to view: "
			set-mode "view"
			set-mode bcolor "red"
		~endm

		write-message "[Consult macro has been loaded]"

	only the lines between the store-macro command and the ~ENDM
	directive are stored in macro 26.  Both numbered macros and named
	procedures (via the store-procedure command) should be terminated
	with this directive.


    ~FORCE Directive
    ----------------
	When a macro is executed, if any command fails, the macro is
	terminated at that point.  If a line is preceded by a ~FORCE
	directive, execution continues whether the command succeeds or not.
	For example:

		set-variable %quest "What file? "
		find-file @%quest
		~force set-mode bcolor "red"
		goto-beginning-of-file
		insert-string "this is a new first line in that file\n"

	will function correctly even if this version of the editor does not
	support color.  (Currently, only the DOS version supports color.)


    ~IF, ~ENDIF, ~ELSE, and ~ENDIF Directives
    -----------------------------------------
	This directive allows statements to be executed only if a condition
	specified in the directive is met.  Every line following the ~IF
	directive, until the first ~ELSE or ~ENDIF directive, is only
	executed if the expression following the ~IF directive evaluates to
	a TRUE value.  For example, the following macro segment creates the
	portion of a text file automatically.

	    ~if &sequal %curplace "timespace vortex"
		    insert-string "First, rematerialize\n"
	    ~endif
	    ~if &sequal %planet "earth"     ;If we have landed on earth...
		~if &sequal %time "late 20th century"  ;and we are then
			write-message "Contact U.N.I.T."
		~else
			insert-string "Investigate the situation....\n"
			insert-string "(SAY 'stay here Sara')\n"
		~endif
	    ~elseif &sequal %planet "luna"  ;If we have landed on our neighbor...
		write-message "Keep the door closed"
	    ~else
		setv %conditions @"Atmosphere conditions outside? "
		~if &sequal %conditions "safe"
			insert-string &cat "Go outside......" "\n"
			insert-string "lock the door\n"
		~else
			insert-string "Dematerialize..try somewhen else"
			newline
		~endif
	    ~endif


    ~GOTO Directive
    ---------------
	Flow can be controlled within a macro using the ~GOTO directive.
	It takes as an argument a label.  A label consists of a line
	starting with an asterisk (*) and then an alphanumeric label.  Only
	labels in the currently executing macro can be jumped to, and
	trying to jump to a non-existing label terminates execution of a
	macro.  For example..

		;Create a block of DATA statements for a BASIC program

			insert-string "1000 DATA "
			setv %linenum 1000

		*nxtin
			update-screen           ;make sure we see the changes
			setv %data @"Next number: "
			~if &equal %data 0
				~goto finish
			~endif

			~if &greater $curcol 60
				2 delete-previous-character
				newline
				setv %linenum &add %linenum 10
				insert-string &cat %linenum " DATA "
			~endif

			insert-string &cat %data ", "
			~goto nxtin

		*finish

			2 delete-previous-character
			newline


    ~WHILE and ~ENDWHILE Directives
    -------------------------------
	This directive allows you to set up repetitive tasks easily and
	efficiently.  If a group of statements need to be executed while a
	certain condition is true, enclose them with a while loop.  For
	example,

		~while &less $curcol 70
			insert-string &cat &cat "[" <stuff "]"
		~endwhile

	places items from buffer "stuff" in the current line until the
	cursor is at or past column 70.  While loops may be nested and can
	contain and be the targets of ~GOTOs with no ill effects.  Using a
	while loop to enclose a repeated task will run much faster than the
	corresponding construct using ~IFs.


    ~BREAK Directive
    ----------------
	This directive allows the user to abort out of the currently most
	inner while loop, regardless of the condition.  It is often used to
	abort processing for error conditions.  For example:

	;       Read in files and substitute "begining" with "beginning"

		setv %filename <list
		~while &not &seq %filename "<end>"
			~force  find-file %filename
			~if &seq $status FALSE
				write-message "[File read error]"
				~break
			~endif
			beginning-of-file
			replace-string "begining" "beginning"
			save-file
			setv %filename <list
		~endwhile

	This while loop will process files until the list is exhausted or
	there is an error while reading a file.


    ~RETURN Directive
    -----------------
	The ~RETURN Directive causes the current macro to exit, either
	returning to the caller (if any) or to interactive mode.  For
	example:

	;       Check the monitor type and setv %mtyp

		~if &sres "CGA"
			setv %mtyp 1
		~else
			setv %mtyp 2
			~return
		~endif

		insert-string "You are on an old machine!\n"


Editor commands
---------------
	The "show-commands" command lists _all_ available editor commands.
	This is, admittedly, a large list and generally grows with
	successive releases of the editor.  Fortunately, most editor
	commands include short help strings that describe their purpose.
	To winnow the list to a particular area of interest, use the
	"apropos" command (e.g., "apropos append").  The format of the
	"apropos" and "show-commands" listing is as follows:

		command-name             optional-key-binding(s)
		optional-command-name-aliases
		(help-string)

	Commands fall into three broad categories:  simple, motion, operator.

    Simple commands
    ---------------
	A simple command neither acts on a region nor does it explicitly
	move the cursor through a region (the "region" concept is explained
	in the "Motion commands" section below).  An example of a simple
	command is "find-tag", and here's the listing returned by
	show-commands:

		"find-tag"		 ^]
		  or		"ta"
		  or		"tag"
		  ( look up the given (or under-cursor) name as a "tag" )

	From the perspective of writing a macro, it can be seen that
	find-tag has two aliases, either of which may be substituted for
	the "find-tag" name within a macro definition.  Notice that the
	help string mentions a "name" argument and sure enough, if you type
	":find-tag" within the editor, you'll be prompted for a "Tag name".
	This gives us enough information to write a contrived macro that
	finds a fixed tag name:

		store-procedure tryit
			tag "filterregion"
		~endm

	Note also that some help strings include a "CNT" keyword, which
	indicates that the command name may be preceded by an integer count
	that repeats the command action that many times (default CNT value
	is 1).  For example, here's the "join-lines" listing:

		"join-lines"     J
		  ( join CNT lines together with the current one )

	And here's a macro that joins 4 lines:

		store-procedure join4
			4 join-lines
		~endm

    Motion commands
    ---------------
	Motions move the cursor and, consequently, may be used to define a
	region.  This latter property is an important aspect of an
	"operator command".  The "show-motions" command lists the editor's
	motion commands.

	Within a macro, the following general syntax invokes a motion:

		[count] region-spec

	The optional "count" specifies the number of affected region-specs
	(default value is 1).  An example motion is "back-line", and here
	is its show-commands listing:

		"back-line"              k         #-A
		  or	"previous-line"
		  or	"up-arrow"
		  or	"up-line"
		  (motion: move up CNT lines )

	Note that the help string is prefixed with the word "motion", which
	unambiguously identifies the nature of this command.  Given the
	above information, we can write a contrived macro to move the
	cursor up three lines:

		store-procedure upthree
			3 back-line
		~endm

    Operator commands
    -----------------
	Operators manipulate regions.  The "show-operators" command lists
	the editor's operator commands.  By convention, most operator names
	end with "-til" (short for "until").

	Within a macro, the following general syntax invokes an operator:

		[count] oper-name region-spec [args...]

	where:

	region-spec    may be replaced with any motion command or the special
	               word "lines" (the latter is a synonym for a single
	               buffer line).

	count          optionally specifies the number of region-specs
	               affected by oper-name (default value is 1).

	args           denotes optional string arguments(s) required by
	               some operators (e.g., "filter-til").

	An example operator is "flip-til", and here's its show-commands
	info:

		"flip-til"               ^A-~
		  or	"~"
		  (operator:  exchange upper and lowercase on characters in the
		  region) (may follow global command)

	A salient point to note within the help string is the "operator"
	keyword, which unambiguously identifies the purpose of this command.
	Given the above information, we can write a macro to flip the case
	of the current paragraph.

		store-procedure flippara
			up-paragraph            ; move to beginning of para
			flip-til down-paragraph ; flip case of entire para
		~endm

	One might be tempted to bind this macro to a key using this syntax:

		bind-key flippara g

	and then attempt to use a numerical argument to control the number
	of affected paragraphs.  I.E., type "3g" to flip three paragraphs.
	But this actually invokes "flippara" three times in a row, which
	(due to the sequential up- and down-paragraph motions), flips the
	case of the _same_ paragraph three times.  However, we can workaround
	that obstacle with the use of an interactive variable:

		store-procedure flippara
			setv %dflt 1
			setv %quest @&cat &cat "Flip how many para [" %dflt "]? "
			~if &sequal %quest ""
				setv %quest %dflt
			~endif
			up-paragraph
			%quest flip-til down-paragraph
		~endm


Debugging macros
----------------
	vile's popup-msgs mode pops up the [Messages] buffer to show text
	written to the message line.  Closing the [Messages] buffer window
	clears its content until the next message is written.  This mode is
	most useful when debugging macros, since many messages may appear,
	each overwriting a previous one.

	Let's use this macro fragment for illustration:

		~if &greater $blines 0
			; buffer has at least one line of data, proceed
		~else
			; this is unexpected!
		~endif

	Suppose the macro is taking the unexpected code path in one of
	several buffers, but you don't know which.  To trace the path,
	modify the macro like so:

		~if &greater $blines 0
			; buffer has at least one line of data, proceed
		~else
			; this is unexpected!
			setv %msg &cat "Error: Buffer " &cat $cbufname " empty"
			write-message %msg
		~endif

	Next, enable popup-msgs (i.e., set popup-msgs) and then start the
	macro.  When the "write-message" command is executed, the
	[Messages] buffer pops up and displays the string written by the
	unexpected code path.

	Disable popup-msgs using this command:  set nopopup-msgs


Example startup file
--------------------
	The startup file include below illustrates several of the language
	constructs described in this document.  This example is crafted for
	the win32 environment, but its syntax and usage are applicable to
	any host OS supported by vile.

	============================ vile.rc ========================
	set ai
	set aw
	set ts=4
	set sw=4
	set flash
	bind-key next-window ^N
	bind-key previous-window ^P

	~if &sequal $progname "winvile"
	    set-variable $font "r_ansi,8"
	    set force-console
	    set w32pipes
	~elseif &equal 0 &sindex &lower $shell "command.com"
	    set w32pipes
	~else
	    set now32pipes
	~endif

	~if &not &equal 0 &sindex $cfgopts "perl"
	    store-procedure hgrep
	        perl "require 'hgrep.pl'"
	        perl hgrep
	        error-buffer $cbufname
	    ~endm
	~endif

	~if &not &equal 0 &sindex $cfgopts "oleauto"
	    set redirect-keys=&cat &global redirect-keys ",MULTIPLY:A:S"
	~endif

	30 store-macro
	    write-message "[Attaching C/C++ attributes...]"
	    set-variable %savcol $curcol
	    set-variable %savline $curline
	    set-variable %modified $modified
	    goto-beginning-of-file
	    filter-til end-of-file "vile-c-filt"
	    goto-beginning-of-file
	    attribute-cntl_a-sequences-til end-of-file
	    ~if &not %modified
	        unmark-buffer
	    ~endif
	    %savline goto-line
	    %savcol goto-column
	    write-message "[Attaching C/C++ attributes...done ]"
	~endm
	bind-key execute-macro-30 ^X-q

	;maybe someday :-)
	;set proj-root "e:/cm/projects/vile.8.0a"
	;set proj-enable
	========================= end vile.rc =======================

-----------------------------------
  $Header: /users/source/archives/vile.vcs/doc/RCS/macros.doc,v 1.6 1998/11/05 00:42:52 cmorgan Exp $
-----------------------------------
